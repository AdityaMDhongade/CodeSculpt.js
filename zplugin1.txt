// babel-tracer.js
const t = require("@babel/types");

// --- Helpers ---
function getLine(node) {
  return node && node.loc ? node.loc.start.line : -1;
}

function makeLog(path, type, extraProps = []) {
  const line = getLine(path.node);
  return t.expressionStatement(
    t.callExpression(t.identifier("__log"), [
      t.objectExpression([
        t.objectProperty(t.identifier("action"), t.stringLiteral(type)),
        t.objectProperty(t.identifier("line"), t.numericLiteral(line)),
        ...extraProps,
      ]),
    ])
  );
}

// --- Logging helpers ---
function logDeclaration(path, decl) {
  const initExpr = decl.init
    ? t.cloneNode(decl.init)
    : t.unaryExpression("void", t.numericLiteral(0)); // â†’ undefined

  return makeLog(path, "declare", [
    t.objectProperty(
      t.identifier("locals"),
      t.objectExpression([
        t.objectProperty(
          t.identifier(decl.id.name),
          t.callExpression(t.identifier("__clone"), [initExpr])
        ),
      ])
    ),
  ]);
}

function logAssignment(path, left, right) {
  const target = t.isIdentifier(left) ? t.identifier(left.name) : t.stringLiteral("complex");
  return makeLog(path, "assign", [
    t.objectProperty(
      t.identifier("locals"),
      t.objectExpression([
        t.objectProperty(target, t.callExpression(t.identifier("__clone"), [t.cloneNode(right)])),
      ])
    ),
  ]);
}

// --- Plugin ---
module.exports = function tracerPlugin() {
  return {
    visitor: {
      // --- Variable Declarations ---
      VariableDeclaration(path) {
        path.node.declarations.forEach((decl) => {
          if (t.isIdentifier(decl.id)) {
            path.insertAfter(logDeclaration(path, decl));
          }
        });
      },

      // --- Assignments ---
      AssignmentExpression(path) {
        if (t.isIdentifier(path.node.left)) {
          // Normal variable assignment
          path.insertAfter(logAssignment(path, path.node.left, path.node.right));
        } 
        else if (t.isMemberExpression(path.node.left) && t.isIdentifier(path.node.left.object)) {
          // arr[i] = value or obj.key = value
          const obj = path.node.left.object;
          path.insertAfter(
            makeLog(path, "assign", [
              t.objectProperty(
                t.identifier("locals"),
                t.objectExpression([
                  t.objectProperty(
                    t.identifier(obj.name),
                    t.callExpression(t.identifier("__clone"), [t.identifier(obj.name)])
                  ),
                ])
              ),
            ])
          );
        } 
        else if (t.isMemberExpression(path.node.left) && t.isThisExpression(path.node.left.object)) {
          path.insertAfter(
            makeLog(path, "assign", [
              t.objectProperty(
                t.identifier("locals"),
                t.objectExpression([
                  t.objectProperty(
                    t.identifier("this"),
                    t.objectExpression([
                      t.objectProperty(
                        path.node.left.property,
                        t.callExpression(t.identifier("__clone"), [t.cloneNode(path.node.right)])
                      ),
                    ])
                  ),
                ])
              ),
            ])
          );
        }
      },

      // --- Function Declarations ---
      FunctionDeclaration(path) {
        const fnName = path.node.id?.name || "anonymous";
        const params = path.node.params.map((p) =>
          t.objectProperty(
            t.identifier(p.name || "param"),
            t.identifier(p.name || "undefined")
          )
        );

        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "call", [
            t.objectProperty(t.identifier("function"), t.stringLiteral(fnName)),
            t.objectProperty(t.identifier("args"), t.objectExpression(params)),
          ])
        );

        path.get("body").pushContainer(
          "body",
          makeLog(path, "return", [
            t.objectProperty(t.identifier("function"), t.stringLiteral(fnName)),
          ])
        );
      },

      // --- Return Statements ---
      ReturnStatement(path) {
        path.insertBefore(
          makeLog(path, "return", [
            t.objectProperty(
              t.identifier("value"),
              path.node.argument
                ? t.callExpression(t.identifier("__clone"), [t.cloneNode(path.node.argument)])
                : t.nullLiteral()
            ),
          ])
        );
      },

      // --- Update Expressions (i++, ++i, j--) ---
      UpdateExpression(path) {
        if (t.isIdentifier(path.node.argument)) {
          const id = path.node.argument;
          path.insertAfter(
            makeLog(path, "assign", [
              t.objectProperty(
                t.identifier("locals"),
                t.objectExpression([
                  t.objectProperty(
                    t.identifier(id.name),
                    t.callExpression(t.identifier("__clone"), [t.identifier(id.name)])
                  ),
                ])
              ),
            ])
          );
        }
      },

      // --- Loops ---
      ForStatement(path) {
        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "loop", [t.objectProperty(t.identifier("type"), t.stringLiteral("for"))])
        );
      },
      WhileStatement(path) {
        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "loop", [t.objectProperty(t.identifier("type"), t.stringLiteral("while"))])
        );
      },
      ForOfStatement(path) {
        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "loop", [t.objectProperty(t.identifier("type"), t.stringLiteral("for-of"))])
        );
      },

      // --- Console.log + Array/Object mutations ---
      CallExpression(path) {
        if (
          t.isMemberExpression(path.node.callee) &&
          path.node.callee.object.name === "console" &&
          path.node.callee.property.name === "log"
        ) {
          path.insertBefore(
            makeLog(path, "stdout", [
              t.objectProperty(
                t.identifier("output"),
                path.node.arguments[0]
                  ? t.callExpression(t.identifier("__clone"), [t.cloneNode(path.node.arguments[0])])
                  : t.stringLiteral("")
              ),
            ])
          );
        }

        // Log object instantiation: new MyClass()
        if (t.isNewExpression(path.node)) {
          path.insertBefore(
            makeLog(path, "instantiate", [
              t.objectProperty(t.identifier("class"), t.stringLiteral(path.node.callee.name || "AnonymousClass")),
            ])
          );
        }

        // Array/Object mutations like arr.push/pop/splice
        if (t.isMemberExpression(path.node.callee) && t.isIdentifier(path.node.callee.object)) {
          const obj = path.node.callee.object;
          path.insertAfter(
            makeLog(path, "assign", [
              t.objectProperty(
                t.identifier("locals"),
                t.objectExpression([
                  t.objectProperty(
                    t.identifier(obj.name),
                    t.callExpression(t.identifier("__clone"), [t.identifier(obj.name)])
                  ),
                ])
              ),
            ])
          );
        }
      },

      // --- Class Declarations ---
      ClassDeclaration(path) {
        const className = path.node.id?.name || "AnonymousClass";

        path.insertBefore(
          makeLog(path, "class", [t.objectProperty(t.identifier("class"), t.stringLiteral(className))])
        );

        path.traverse({
          ClassMethod(innerPath) {
            const methodName = innerPath.node.kind === "constructor"
              ? "constructor"
              : innerPath.node.key.name;

            const params = innerPath.node.params.map((p) =>
              t.objectProperty(
                t.identifier(p.name || "param"),
                t.identifier(p.name || "undefined")
              )
            );

            innerPath.get("body").unshiftContainer(
              "body",
              makeLog(innerPath, "call", [
                t.objectProperty(t.identifier("function"), t.stringLiteral(methodName)),
                t.objectProperty(t.identifier("args"), t.objectExpression(params)),
              ])
            );

            innerPath.get("body").pushContainer(
              "body",
              makeLog(innerPath, "return", [
                t.objectProperty(t.identifier("function"), t.stringLiteral(methodName)),
              ])
            );

            innerPath.traverse({
              AssignmentExpression(innerAssign) {
                if (
                  t.isMemberExpression(innerAssign.node.left) &&
                  t.isThisExpression(innerAssign.node.left.object)
                ) {
                  innerAssign.insertAfter(
                    makeLog(innerAssign, "assign", [
                      t.objectProperty(
                        t.identifier("locals"),
                        t.objectExpression([
                          t.objectProperty(
                            t.identifier("this"),
                            t.objectExpression([
                              t.objectProperty(
                                innerAssign.node.left.property,
                                t.callExpression(t.identifier("__clone"), [t.cloneNode(innerAssign.node.right)])
                              ),
                            ])
                          ),
                        ])
                      ),
                    ])
                  );
                }
              },
            });
          },
        });
      },
    },
  };
};

original from chatgpt