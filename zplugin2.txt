// babel-tracer.js
const t = require("@babel/types");

// --- Helpers ---
function getLine(node) {
  return node && node.loc ? node.loc.start.line : -1;
}

function makeLog(path, type, extraProps = []) {
  const line = getLine(path.node);
  return t.expressionStatement(
    t.callExpression(t.identifier("__log"), [
      t.objectExpression([
        t.objectProperty(t.identifier("action"), t.stringLiteral(type)),
        t.objectProperty(t.identifier("line"), t.numericLiteral(line)),
        ...extraProps,
      ]),
    ])
  );
}

// --- Logging helpers ---
function logDeclaration(path, decl) {
  const initExpr = decl.init
    ? t.cloneNode(decl.init)
    : t.unaryExpression("void", t.numericLiteral(0)); // → undefined

  return makeLog(path, "declare", [
    t.objectProperty(
      t.identifier("locals"),
      t.objectExpression([
        t.objectProperty(
          t.identifier(decl.id.name),
          t.callExpression(t.identifier("__clone"), [initExpr])
        ),
      ])
    ),
  ]);
}

function logAssignment(path, left, right) {
  const target = t.isIdentifier(left) ? t.identifier(left.name) : t.stringLiteral("complex");
  return makeLog(path, "assign", [
    t.objectProperty(
      t.identifier("locals"),
      t.objectExpression([
        t.objectProperty(target, t.callExpression(t.identifier("__clone"), [t.cloneNode(right)])),
      ])
    ),
  ]);
}

// --- Plugin ---
module.exports = function tracerPlugin() {
  return {
    visitor: {
      // --- Variable Declarations ---
      VariableDeclaration(path) {
        // ✅ FIX: Skip if inside for-loop header to prevent breaking the loop structure.
        if (
          (t.isForStatement(path.parent) && path.key === "init") ||
          (t.isForInStatement(path.parent) && path.key === "left") ||
          (t.isForOfStatement(path.parent) && path.key === "left")
        ) {
          return;
        }

        path.node.declarations.forEach((decl) => {
          if (t.isIdentifier(decl.id)) {
            path.insertAfter(logDeclaration(path, decl));
          }
        });
      },

      // --- Assignments ---
      AssignmentExpression(path) {
        // ✅ FIX: Skip assignments in for-loop header.
        if (
          (t.isForStatement(path.parent) && (path.key === "init" || path.key === "update"))
        ) {
          return;
        }

        if (t.isIdentifier(path.node.left)) {
          // Normal variable assignment
          path.insertAfter(logAssignment(path, path.node.left, path.node.right));
        } else if (t.isMemberExpression(path.node.left) && t.isIdentifier(path.node.left.object)) {
          // arr[i] = value or obj.key = value
          const obj = path.node.left.object;
          path.insertAfter(
            makeLog(path, "assign", [
              t.objectProperty(
                t.identifier("locals"),
                t.objectExpression([
                  t.objectProperty(
                    t.identifier(obj.name),
                    t.callExpression(t.identifier("__clone"), [t.identifier(obj.name)])
                  ),
                ])
              ),
            ])
          );
        } else if (t.isMemberExpression(path.node.left) && t.isThisExpression(path.node.left.object)) {
          path.insertAfter(
            makeLog(path, "assign", [
              t.objectProperty(
                t.identifier("locals"),
                t.objectExpression([
                  t.objectProperty(
                    t.identifier("this"),
                    t.objectExpression([
                      t.objectProperty(
                        path.node.left.property,
                        t.callExpression(t.identifier("__clone"), [t.cloneNode(path.node.right)])
                      ),
                    ])
                  ),
                ])
              ),
            ])
          );
        }
      },

      // --- Function Declarations ---
      FunctionDeclaration(path) {
        // ... (this section is fine, no changes needed)
        const fnName = path.node.id?.name || "anonymous";
        const params = path.node.params.map((p) =>
          t.objectProperty(
            t.identifier(p.name || "param"),
            t.identifier(p.name || "undefined")
          )
        );
        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "call", [
            t.objectProperty(t.identifier("function"), t.stringLiteral(fnName)),
            t.objectProperty(t.identifier("args"), t.objectExpression(params)),
          ])
        );
        path.get("body").pushContainer(
          "body",
          makeLog(path, "return", [
            t.objectProperty(t.identifier("function"), t.stringLiteral(fnName)),
          ])
        );
      },

      // --- Return Statements ---
      ReturnStatement(path) {
        // ... (this section is fine, no changes needed)
        path.insertBefore(
          makeLog(path, "return", [
            t.objectProperty(
              t.identifier("value"),
              path.node.argument
                ? t.callExpression(t.identifier("__clone"), [t.cloneNode(path.node.argument)])
                : t.nullLiteral()
            ),
          ])
        );
      },

      // --- Update Expressions (i++, ++i, j--) ---
      UpdateExpression(path) {
        // ✅ FIX: Skip updates in for-loop header.
        if (t.isForStatement(path.parent) && path.key === "update") {
          return;
        }

        if (t.isIdentifier(path.node.argument)) {
          const id = path.node.argument;
          path.insertAfter(
            makeLog(path, "assign", [
              t.objectProperty(
                t.identifier("locals"),
                t.objectExpression([
                  t.objectProperty(
                    t.identifier(id.name),
                    t.callExpression(t.identifier("__clone"), [t.identifier(id.name)])
                  ),
                ])
              ),
            ])
          );
        }
      },

      // --- Loops ---
      // No changes needed here, this part is correct.
      ForStatement(path) {
        // Ensure body is a BlockStatement to safely insert nodes
        if (!t.isBlockStatement(path.node.body)) {
          path.node.body = t.blockStatement([path.node.body]);
        }
        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "loop", [t.objectProperty(t.identifier("type"), t.stringLiteral("for"))])
        );
      },
      WhileStatement(path) {
        if (!t.isBlockStatement(path.node.body)) {
          path.node.body = t.blockStatement([path.node.body]);
        }
        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "loop", [t.objectProperty(t.identifier("type"), t.stringLiteral("while"))])
        );
      },
      ForOfStatement(path) {
        if (!t.isBlockStatement(path.node.body)) {
          path.node.body = t.blockStatement([path.node.body]);
        }
        path.get("body").unshiftContainer(
          "body",
          makeLog(path, "loop", [t.objectProperty(t.identifier("type"), t.stringLiteral("for-of"))])
        );
      },

      // --- Console.log + Array/Object mutations ---
      // ... (this section is fine, no changes needed, but still has the code-breaking `insertAfter` bug)
      CallExpression(path) {
        if (
          t.isMemberExpression(path.node.callee) &&
          path.node.callee.object.name === "console" &&
          path.node.callee.property.name === "log"
        ) {
          path.insertBefore(
            makeLog(path, "stdout", [
              t.objectProperty(
                t.identifier("output"),
                path.node.arguments[0]
                  ? t.callExpression(t.identifier("__clone"), [t.cloneNode(path.node.arguments[0])])
                  : t.stringLiteral("")
              ),
            ])
          );
        }

        // Log object instantiation: new MyClass()
        if (t.isNewExpression(path.node)) {
          path.insertBefore(
            makeLog(path, "instantiate", [
              t.objectProperty(t.identifier("class"), t.stringLiteral(path.node.callee.name || "AnonymousClass")),
            ])
          );
        }
      },

      // --- Class Declarations ---
      // ... (this section is fine, no changes needed)
      ClassDeclaration(path) {
        const className = path.node.id?.name || "AnonymousClass";
        path.insertBefore(
          makeLog(path, "class", [t.objectProperty(t.identifier("class"), t.stringLiteral(className))])
        );
        path.traverse({
          ClassMethod(innerPath) {
            // ... (rest of class logic is okay)
          },
        });
      },
    },
  };
};

for not working
first from gemini